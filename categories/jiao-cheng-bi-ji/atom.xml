<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - 教程&#x2F;笔记</title>
    <link rel="self" type="application/atom+xml" href="https://sudoytang.github.io/categories/jiao-cheng-bi-ji/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://sudoytang.github.io/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-10-24T00:00:00+00:00</updated>
    <id>https://sudoytang.github.io/categories/jiao-cheng-bi-ji/atom.xml</id>
    <entry xml:lang="en">
        <title>从C语言理解Rust Aliasing Rule</title>
        <published>2025-10-24T00:00:00+00:00</published>
        <updated>2025-10-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://sudoytang.github.io/rust-aliasing-rules/"/>
        <id>https://sudoytang.github.io/rust-aliasing-rules/</id>
        
        <content type="html" xml:base="https://sudoytang.github.io/rust-aliasing-rules/">&lt;h2 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h2&gt;
&lt;p&gt;在学习 Rust 的过程中，我们经常听说 Rust 的借用检查器（borrow checker）不仅保证了内存安全，还能帮助编译器做出更激进的优化。
Prof. Baochun Li 在 ECE 1724 Rust 课程的《Lifetimes》Lecture 中提到了 Aliasing，并举了以下例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut u32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output *= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; `*output` will be `2` if `input &amp;gt; 10`
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;他从可优化性的角度解释了 aliasing 假设对编译优化的影响。然而，对于被 borrow checker 保护得太好的 Rust 使用者来说，这段代码的可优化性似乎是理所当然的——毕竟借用规则不允许同时存在可变引用和不可变引用。这反而让人有点摸不着头脑：这和优化有什么关系？&lt;&#x2F;p&gt;
&lt;p&gt;要真正理解这个问题，我们需要回到 C 语言，看看在没有借用检查的世界里，编译器面临着怎样的困境。本文将从 C 语言的 aliasing 问题出发，逐步理解 Rust 的 aliasing rule 为编译器带来的价值。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cyu-yan-zhong-de-aliasing-rule&quot;&gt;C语言中的 Aliasing Rule&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;shen-me-shi-aliasing&quot;&gt;什么是 Aliasing？&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Aliasing（别名）&lt;&#x2F;strong&gt; 指的是两个或多个指针指向同一块内存区域的情况。当函数接收多个指针参数时，因为这些指针可能来自任何地方，编译器通常无法确定这些指针是否会指向重叠的内存，这就是 &lt;strong&gt;pointer aliasing problem&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;一个经典的例子是 C 标准库中的 &lt;code&gt;memcpy&lt;&#x2F;code&gt; 和 &lt;code&gt;memmove&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;memcpy&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;restrict &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dest&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;restrict &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;memmove&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;dest&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;src&lt;&#x2F;span&gt;&lt;span&gt;, size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意到它们的函数签名有一个关键区别：&lt;code&gt;memcpy&lt;&#x2F;code&gt; 的参数带有 &lt;code&gt;restrict&lt;&#x2F;code&gt; 关键字，而 &lt;code&gt;memmove&lt;&#x2F;code&gt; 没有。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;memcpy&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：假设源和目标内存区域&lt;strong&gt;不重叠&lt;&#x2F;strong&gt;（no-alias），可以做激进优化（如并行拷贝、向量化）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;memmove&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：允许源和目标内存区域&lt;strong&gt;重叠&lt;&#x2F;strong&gt;（may-alias），必须小心处理拷贝顺序&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这两个函数存在的原因正是因为 aliasing 的情况不同，需要不同的实现策略。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-ge-ju-ti-de-li-zi&quot;&gt;一个具体的例子&lt;&#x2F;h3&gt;
&lt;p&gt;让我们把前面的 Rust 例子翻译成 C 语言，看看编译器会生成什么样的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 版本1：不带 restrict
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const unsigned int &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        *output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        *output *= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个版本中，编译器&lt;strong&gt;不知道&lt;&#x2F;strong&gt; &lt;code&gt;input&lt;&#x2F;code&gt; 和 &lt;code&gt;output&lt;&#x2F;code&gt; 是否指向同一块内存。因此它必须保守地假设它们&lt;strong&gt;可能&lt;&#x2F;strong&gt;指向同一地址。&lt;&#x2F;p&gt;
&lt;p&gt;让我们看看编译器会做什么（使用 &lt;code&gt;gcc -O2&lt;&#x2F;code&gt; 编译）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; unsigned temp = *arg0;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jle     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                     ; if (temp &amp;gt; 10) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;      ;   *arg1 = 1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ;   temp = *arg0;   &#x2F;&#x2F; 注意：这里重新从内存取了值
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L2:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                    ; }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jle     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                     ; if (temp &amp;gt; 5) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;sal     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;         ;   *arg2 &amp;lt;&amp;lt;= 1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L1:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                    ; }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意关键的一点：&lt;code&gt;*input&lt;&#x2F;code&gt; 被&lt;strong&gt;读取了两次&lt;&#x2F;strong&gt;（第 6 行再次从 &lt;code&gt;[rdi]&lt;&#x2F;code&gt; 读取）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;为什么？&lt;&#x2F;strong&gt; 因为编译器担心 &lt;code&gt;input&lt;&#x2F;code&gt; 和 &lt;code&gt;output&lt;&#x2F;code&gt; 可能指向同一地址。如果它们是同一个指针，那么第一个 &lt;code&gt;if&lt;&#x2F;code&gt; 块中的 &lt;code&gt;*output = 1&lt;&#x2F;code&gt; 就改变了 &lt;code&gt;*input&lt;&#x2F;code&gt; 的值！因此，第二个 &lt;code&gt;if&lt;&#x2F;code&gt; 必须重新读取 &lt;code&gt;*input&lt;&#x2F;code&gt; 的值，不能直接使用之前读取的值。&lt;&#x2F;p&gt;
&lt;p&gt;这就是 aliasing 带来的性能损失：编译器不得不生成保守的代码。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;restrict-guan-jian-zi-gao-su-bian-yi-qi-bu-hui-you-bie-ming&quot;&gt;restrict 关键字：告诉编译器&quot;不会有别名&quot;&lt;&#x2F;h3&gt;
&lt;p&gt;C99 引入了 &lt;code&gt;restrict&lt;&#x2F;code&gt; 关键字，它是程序员向编译器做出的&lt;strong&gt;承诺&lt;&#x2F;strong&gt;：这个指针指向的内存区域在函数执行期间不会通过其他指针访问。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 版本2：带 restrict
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute_restrict&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const unsigned int &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;restrict &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;, 
&lt;&#x2F;span&gt;&lt;span&gt;                      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsigned int &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;restrict &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        *output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        *output *= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;现在我们只是在函数签名上加了 &lt;code&gt;restrict&lt;&#x2F;code&gt;，函数体完全相同。再看编译结果（&lt;code&gt;gcc -O2&lt;&#x2F;code&gt;）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute_restrict:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; unsigned temp = *arg0;  &#x2F;&#x2F; 注意：只读取一次arg0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jg      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                     ; if (temp &amp;gt; 10) goto L8;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jg      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                     ; if (temp &amp;gt; 5) goto L9;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ;   return;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L8:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                    ; L8:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; temp = 2;  &#x2F;&#x2F; 注意：这里直接得到 *arg1 = 1 * 2;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; *arg1 = temp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.L9:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                    ; L9:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; temp = *arg1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                ; temp *= 2;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; *arg1 = temp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;对比两个版本，区别非常明显：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;*input&lt;&#x2F;code&gt; 只被读取一次&lt;&#x2F;strong&gt;（第 1 行 &lt;code&gt;mov eax, DWORD PTR [rdi]&lt;&#x2F;code&gt;）：编译器知道 &lt;code&gt;*output = 1&lt;&#x2F;code&gt; 不会影响 &lt;code&gt;*input&lt;&#x2F;code&gt; 的值，可以在之后的比较中继续使用寄存器 &lt;code&gt;eax&lt;&#x2F;code&gt; 中的值&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;更激进的优化&lt;&#x2F;strong&gt;：当 &lt;code&gt;*input &amp;gt; 10&lt;&#x2F;code&gt; 时（&lt;code&gt;.L8&lt;&#x2F;code&gt; 分支），编译器推导出最终结果是 &lt;code&gt;2&lt;&#x2F;code&gt;，直接将常量 &lt;code&gt;2&lt;&#x2F;code&gt; 赋值并写入 &lt;code&gt;*output&lt;&#x2F;code&gt;，而不是先写 &lt;code&gt;1&lt;&#x2F;code&gt; 再乘以 &lt;code&gt;2&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这就是 &lt;code&gt;restrict&lt;&#x2F;code&gt; 关键字的威力：它让编译器能够根据 no-alias 假设进行更全面的优化。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rustde-aliasing-rule&quot;&gt;Rust的Aliasing Rule&lt;&#x2F;h2&gt;
&lt;p&gt;现在我们回到 Rust。理解了 C 语言的问题后，Rust 的优势就显而易见了。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yin-yong-tian-ran-bao-zheng-no-aliasing&quot;&gt;引用天然保证 No-Aliasing&lt;&#x2F;h3&gt;
&lt;p&gt;Rust 对引用有严格的借用规则：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要么&lt;&#x2F;strong&gt;有多个不可变引用（&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;要么&lt;&#x2F;strong&gt;有一个可变引用（&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;但不能同时存在&lt;&#x2F;strong&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这个规则天然地保证了：&lt;strong&gt;当存在可变引用时，不会有其他引用指向同一块内存&lt;&#x2F;strong&gt;。这正是 no-aliasing 的定义！&lt;&#x2F;p&gt;
&lt;p&gt;让我们看看文章开头的 Rust 例子会被编译成什么：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut u32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output *= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译结果 (&lt;code&gt;-C opt-level=3&lt;&#x2F;code&gt;)：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; unsigned input_val = *arg0;  &#x2F;&#x2F; 注意：只读取一次
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; unsigned result = 2; &#x2F;&#x2F; 优化：预先计算出 *input &amp;gt; 10 时 *output = 2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ja      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; if (input_val &amp;gt; 10) goto LBB0_3;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jb      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; if (input_val &amp;lt;= 5) return;  &#x2F;&#x2F; 两个条件都不满足，什么也不做
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; result = *arg1;              &#x2F;&#x2F; 只满足第二个条件，乘2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                ; result *= 2;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_3:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                ; LBB0_3:   &#x2F;&#x2F; 如果 *input &amp;gt; 10 会跳到这里
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; *arg1 = result;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_4:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;*input&lt;&#x2F;code&gt; 同样只被读取一次（第 1 行，保存在 &lt;code&gt;ecx&lt;&#x2F;code&gt; 中），编译器还预先将常量 &lt;code&gt;2&lt;&#x2F;code&gt; 加载到 &lt;code&gt;eax&lt;&#x2F;code&gt; 中（第 2 行），为 &lt;code&gt;*input &amp;gt; 10&lt;&#x2F;code&gt; 的情况做准备。当 &lt;code&gt;*input &amp;gt; 10&lt;&#x2F;code&gt; 时，会跳转到 &lt;code&gt;.LBB0_3&lt;&#x2F;code&gt; 直接写入这个预先准备好的值。这和带 &lt;code&gt;restrict&lt;&#x2F;code&gt; 的 C 版本采用了相似的优化策略。&lt;&#x2F;p&gt;
&lt;p&gt;Rust 的借用规则让编译器确信 &lt;code&gt;input&lt;&#x2F;code&gt; 和 &lt;code&gt;output&lt;&#x2F;code&gt; 不会指向同一块内存，因此可以安全地进行激进优化。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;luo-zhi-zhen-hui-dao-c-de-shi-jie&quot;&gt;裸指针：回到 C 的世界&lt;&#x2F;h3&gt;
&lt;p&gt;那么，如果我们绕过借用检查器，使用裸指针（raw pointer）呢？&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub unsafe fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute_raw&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*const u32&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;output&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;*mut u32&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;10 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;*input &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        *output *= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译结果 (&lt;code&gt;-C opt-level=3&lt;&#x2F;code&gt;)：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;compute_raw:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; unsigned temp = *arg0;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jae     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; if (temp &amp;gt;= 11) goto LBB1_1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jae     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; if (temp &amp;gt;= 6) goto LBB1_3;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_4:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_1:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                ; LBB1_1:  &#x2F;&#x2F; temp &amp;gt; 10 会跳到这里
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;      ; *arg1 = 1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; temp = *arg0;  &#x2F;&#x2F; 注意：重新读取内存值
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                  ; 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jb      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                 ; if (temp &amp;lt;= 5) return;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB1_3:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                ; LBB1_3:  &#x2F;&#x2F; temp &amp;gt; 5 会跳到这里
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;shl     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;         ; *arg1 &amp;lt;&amp;lt;= 1;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                             ; return;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，在 &lt;code&gt;.LBB1_1&lt;&#x2F;code&gt; 分支中，&lt;code&gt;*input&lt;&#x2F;code&gt; 被读取了两次（第 1 行和第 10 行，都是 &lt;code&gt;mov eax, dword ptr [rdi]&lt;&#x2F;code&gt;）。这和不带 &lt;code&gt;restrict&lt;&#x2F;code&gt; 的 C 版本的行为一致：编译器必须在写入 &lt;code&gt;*output = 1&lt;&#x2F;code&gt; 之后重新读取 &lt;code&gt;*input&lt;&#x2F;code&gt;，因为它不能确定两个指针是否指向同一块内存。&lt;&#x2F;p&gt;
&lt;p&gt;这说明：&lt;strong&gt;Rust 对裸指针没有 aliasing 假设&lt;&#x2F;strong&gt;。编译器会保守地认为两个裸指针可能指向同一块内存。这是合理的，因为裸指针绕过了借用检查器，编译器无法保证它们的关系。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;borrow-rules-qiang-hua-de-aliasing-rules&quot;&gt;Borrow Rules = 强化的 Aliasing Rules&lt;&#x2F;h3&gt;
&lt;p&gt;通过对比可以看出：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语言&#x2F;方式&lt;&#x2F;th&gt;&lt;th&gt;Aliasing 保证&lt;&#x2F;th&gt;&lt;th&gt;编译器优化&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;C（普通指针）&lt;&#x2F;td&gt;&lt;td&gt;❌ 可能有 alias&lt;&#x2F;td&gt;&lt;td&gt;保守&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;C（restrict）&lt;&#x2F;td&gt;&lt;td&gt;✅ 程序员承诺 no-alias&lt;&#x2F;td&gt;&lt;td&gt;激进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Rust（引用）&lt;&#x2F;td&gt;&lt;td&gt;✅ 编译器强制 no-alias&lt;&#x2F;td&gt;&lt;td&gt;激进&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Rust（裸指针）&lt;&#x2F;td&gt;&lt;td&gt;❌ 可能有 alias&lt;&#x2F;td&gt;&lt;td&gt;保守&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Rust 的借用规则本质上是一种&lt;strong&gt;编译器强制执行的 aliasing rule&lt;&#x2F;strong&gt;。它比 C 的 &lt;code&gt;restrict&lt;&#x2F;code&gt; 更强大，因为：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态检查&lt;&#x2F;strong&gt;：违反规则会在编译时被发现，而不是运行时未定义行为&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;自动推导&lt;&#x2F;strong&gt;：编译器自动知道引用满足 no-alias，不需要程序员手动标注&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;全局保证&lt;&#x2F;strong&gt;：规则在整个程序中强制执行，而 &lt;code&gt;restrict&lt;&#x2F;code&gt; 只是局部承诺&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这就是为什么 Rust 的 borrow checker 不仅保证了内存安全，还能带来性能优势——它为编译器提供了更多的优化信息。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-reference-zen-me-xie-de&quot;&gt;Rust Reference 怎么写的？&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 官方文档在 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-considered-undefined.html#r-undefined.alias&quot;&gt;Undefined Behavior&lt;&#x2F;a&gt; 一节中明确列出了关于 aliasing 的规则。&lt;&#x2F;p&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;Rust 的 pointer aliasing rule 仍在演进中&lt;&#x2F;strong&gt;。目前 Rust 团队正在通过 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;unsafe-code-guidelines&#x2F;blob&#x2F;master&#x2F;wip&#x2F;stacked-borrows.md&quot;&gt;Stacked Borrows&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;perso.crans.org&#x2F;vanille&#x2F;treebor&#x2F;&quot;&gt;Tree Borrows&lt;&#x2F;a&gt; 等模型来形式化这些规则。&lt;&#x2F;p&gt;
&lt;p&gt;但对于涉及&lt;strong&gt;引用&lt;&#x2F;strong&gt;的情况，规则是明确的：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;产生以下情况的引用是未定义行为：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个可变引用（&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt;）与任何其他指向相同内存的引用（无论可变或不可变）同时存活&lt;&#x2F;li&gt;
&lt;li&gt;一个不可变引用（&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt;）与指向相同内存的可变引用同时存活&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这些规则确保了：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;独占性&lt;&#x2F;strong&gt;：&lt;code&gt;&amp;amp;mut T&lt;&#x2F;code&gt; 保证独占访问，编译器可以假设没有其他路径访问这块内存&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;不变性&lt;&#x2F;strong&gt;：&lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; 保证数据不会被修改，编译器可以缓存读取的值&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;编译器正是基于这些保证来进行优化的。违反这些规则（通常通过 &lt;code&gt;unsafe&lt;&#x2F;code&gt; 代码）会导致未定义行为，编译器生成的优化代码可能产生意外结果。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ti-wai-hua-c-de-strict-aliasing-rule&quot;&gt;题外话：C++ 的 Strict Aliasing Rule&lt;&#x2F;h2&gt;
&lt;p&gt;C++ 还有另一种形式的 aliasing rule，称为 &lt;strong&gt;strict aliasing rule&lt;&#x2F;strong&gt;（严格别名规则）。它关注的是&lt;strong&gt;类型&lt;&#x2F;strong&gt;而不是指针本身。&lt;&#x2F;p&gt;
&lt;p&gt;简单来说，C++ 的 strict aliasing rule 规定：&lt;strong&gt;编译器可以假设不同类型的指针不会指向重叠的内存&lt;&#x2F;strong&gt;（除了一些例外，如 &lt;code&gt;char*&lt;&#x2F;code&gt; 可以指向任何类型）。&lt;&#x2F;p&gt;
&lt;p&gt;看一个具体的例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_value&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;p&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;float &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;q&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    *p = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    *q = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*p;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;直觉上，如果 &lt;code&gt;p&lt;&#x2F;code&gt; 和 &lt;code&gt;q&lt;&#x2F;code&gt; 指向同一块内存，这个函数应该返回 &lt;code&gt;3.14f&lt;&#x2F;code&gt; 的位表示（一个整数，通常是 &lt;code&gt;1078523331&lt;&#x2F;code&gt;）。但实际上，编译器会基于 strict aliasing rule 进行优化：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;get_value:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;         ; *arg0 = 42;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                     ; int temp = 42;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;DWORD PTR &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x4048f5c3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; ; *arg1 = 3.14000010f
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                                 ; return temp;  &#x2F;&#x2F; 这里编译器返回了42，而没有重新取arg0指向的值
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注意最后一行：编译器&lt;strong&gt;直接返回常量 &lt;code&gt;42&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;，而不是重新读取 &lt;code&gt;*p&lt;&#x2F;code&gt; 的值。因为编译器假设 &lt;code&gt;int*&lt;&#x2F;code&gt; 和 &lt;code&gt;float*&lt;&#x2F;code&gt; 不会指向同一块内存，所以认为 &lt;code&gt;*q = 3.14f&lt;&#x2F;code&gt; 不会影响 &lt;code&gt;*p&lt;&#x2F;code&gt; 的值。&lt;&#x2F;p&gt;
&lt;p&gt;如果我们真的让 &lt;code&gt;p&lt;&#x2F;code&gt; 和 &lt;code&gt;q&lt;&#x2F;code&gt; 指向同一块内存：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; result = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;get_value&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;value, reinterpret_cast&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;float&lt;&#x2F;span&gt;&lt;span&gt;*&amp;gt;(&amp;amp;value));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; result == 42，而不是 3.14f 的位表示！
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; value 的内存中存储的是 3.14f 的位表示，但函数返回了 42
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是一个违反直觉的结果：内存中的值已经被改变了，但函数返回的却是旧值。这就是 strict aliasing rule 导致的未定义行为——编译器的优化假设被违反了。&lt;&#x2F;p&gt;
&lt;p&gt;这是一种基于&lt;strong&gt;类型的 aliasing rule&lt;&#x2F;strong&gt;，与我们之前讨论的基于&lt;strong&gt;可变性和独占性的 aliasing rule&lt;&#x2F;strong&gt;（Rust&#x2F;C restrict）不同。两者的目标都是给编译器更多优化空间，但约束的角度不同：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;C&#x2F;Rust 的 restrict&#x2F;borrow&lt;&#x2F;strong&gt;：关注同一类型的多个指针是否重叠&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;C++ 的 strict aliasing&lt;&#x2F;strong&gt;：关注不同类型的指针是否重叠&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Rust 也有类似的规则（不同类型的引用不应指向同一内存），但由于 Rust 的类型系统和借用检查器的限制，在安全代码中很难违反这个规则。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;通过从 C 语言的 &lt;code&gt;restrict&lt;&#x2F;code&gt; 关键字出发，我们理解了 aliasing 对编译器优化的影响：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Aliasing 是性能杀手&lt;&#x2F;strong&gt;：当编译器不确定两个指针是否重叠时，必须生成保守的代码&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;C 的 &lt;code&gt;restrict&lt;&#x2F;code&gt;&lt;&#x2F;strong&gt;：程序员手动承诺 no-alias，但没有编译时检查&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rust 的引用&lt;&#x2F;strong&gt;：编译器通过借用规则强制保证 no-alias，自动获得优化&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rust 的裸指针&lt;&#x2F;strong&gt;：和 C 的普通指针一样，编译器保守处理&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Rust 的借用检查器本质上是&lt;strong&gt;把 aliasing rule 编码到类型系统中&lt;&#x2F;strong&gt;，在保证内存安全的同时，也为编译器提供了丰富的优化信息。这是 Rust &quot;零成本抽象&quot;理念的一个完美体现：安全的代码也是高效的代码。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;behavior-considered-undefined.html&quot;&gt;Rust Reference: Behavior considered undefined&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;aliasing.html&quot;&gt;The Rustonomicon: Aliasing&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;c&#x2F;language&#x2F;restrict&quot;&gt;C99 Standard: The restrict type qualifier&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;unsafe-code-guidelines&#x2F;blob&#x2F;master&#x2F;wip&#x2F;stacked-borrows.md&quot;&gt;Stacked Borrows: An Aliasing Model For Rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>手写Rust异步执行器 第0章：入门</title>
        <published>2025-10-21T00:00:00+00:00</published>
        <updated>2025-10-21T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://sudoytang.github.io/rust-async-chapter-00-intro/"/>
        <id>https://sudoytang.github.io/rust-async-chapter-00-intro/</id>
        
        <content type="html" xml:base="https://sudoytang.github.io/rust-async-chapter-00-intro/">&lt;h2 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h2&gt;
&lt;p&gt;虽然我在近几年写的代码几乎都是同步的，但是最近在学习Rust的过程中，得益于Rust的并发模型很好地规避了初学者在使用时容易踩的坑，因此我也对并发编程有了一定的了解。Rust的并发编程除了多进程和多线程外，还有一套异步编程模型。我尝试过使用 Tokio 这样的异步运行时，但对它们的内部机制始终是一知半解。为了真正理解 Rust 异步编程的底层原理，我决定从零开始实现一个学习性质的异步运行时。它的目标不是打造一个生产级的运行时，而是通过动手实践来深入理解 Future、Waker、Executor 这些概念是如何协同工作的。&lt;&#x2F;p&gt;
&lt;p&gt;本系列笔记记录了我在这个过程中的学习和思考。&lt;&#x2F;p&gt;
&lt;p&gt;在开始动手实现之前，先梳理一下异步编程的基本概念：它是什么、为什么需要它、以及它和多线程的区别。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shen-me-shi-yi-bu-bian-cheng&quot;&gt;什么是异步编程？&lt;&#x2F;h2&gt;
&lt;p&gt;简单来说，异步编程就是一种&lt;strong&gt;让程序在等待某些操作完成的时候，不傻站着干等，而是去做点别的事情&lt;&#x2F;strong&gt;的编程方式。&lt;&#x2F;p&gt;
&lt;p&gt;举个生活中的例子，煮饭的场景：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同步方式&lt;&#x2F;strong&gt;：把米放进电饭煲，然后站在那里盯着它煮熟（30分钟），什么都不干。煮好了，再去烧菜（15分钟），烧好了再去煮汤（10分钟）。总共需要 55 分钟。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;异步方式&lt;&#x2F;strong&gt;：把米放进电饭煲，设好定时器，然后去烧菜。烧菜的同时电饭煲在工作。烧完菜再去煮汤。饭、菜、汤可能在 30-35 分钟内全部完成。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;异步编程的核心思想就是：&lt;strong&gt;不要浪费等待的时间&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在计算机程序中，有大量的操作需要&quot;等待&quot;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;从网络读取数据（等待网卡）&lt;&#x2F;li&gt;
&lt;li&gt;从磁盘读取文件（等待硬盘）&lt;&#x2F;li&gt;
&lt;li&gt;等待用户输入（等待用户）&lt;&#x2F;li&gt;
&lt;li&gt;等待数据库查询结果（等待数据库服务器）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些操作的共同特点是：&lt;strong&gt;CPU 实际上是空闲的，它只是在等外部设备或系统完成工作&lt;&#x2F;strong&gt;。如果能在等待的时候去处理其他任务，程序的效率就会大大提高。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yi-bu-bing-fa-yu-duo-xian-cheng-wei-shen-me-xuan-ze-yi-bu&quot;&gt;异步并发与多线程：为什么选择异步？&lt;&#x2F;h2&gt;
&lt;p&gt;在并发编程中，有两种主要的实现方式：多线程和异步。它们经常被混淆，但有着本质的区别。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;duo-xian-cheng-parallel-concurrent&quot;&gt;多线程（Parallel&#x2F;Concurrent）&lt;&#x2F;h3&gt;
&lt;p&gt;在多核系统上：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;线程 1: [==任务A==]     [==任务C==]
&lt;&#x2F;span&gt;&lt;span&gt;线程 2:     [==任务B==]     [==任务D==]
&lt;&#x2F;span&gt;&lt;span&gt;        |----时间线----&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在单核系统上：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;线程 1: [==任务A==][被抢占]  [==任务A继续==][被抢占]
&lt;&#x2F;span&gt;&lt;span&gt;线程 2:          [==任务B==]            [==任务B继续==]
&lt;&#x2F;span&gt;&lt;span&gt;        |----时间线----&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;(可能)真正的并行&lt;&#x2F;strong&gt;：在多核 CPU 上，多个线程可以同时执行；在单核上则是操作系统快速切换造成的&quot;并发&quot;假象&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;抢占式调度&lt;&#x2F;strong&gt;：操作系统决定什么时候切换线程，程序无法控制&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;高开销&lt;&#x2F;strong&gt;：每个线程有独立的栈（通常 1-2MB），上下文切换代价高&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;&#x2F;strong&gt;：CPU 密集型任务，需要利用多核心进行计算&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;yi-bu-bing-fa-concurrent&quot;&gt;异步并发（Concurrent）&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;线程 1: [任务A-等待][任务B-等待][任务C-等待][任务A-继续][任务B-继续]
&lt;&#x2F;span&gt;&lt;span&gt;        |----时间线----&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单线程也能并发&lt;&#x2F;strong&gt;：通过任务切换实现，无需多核支持&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;协作式调度&lt;&#x2F;strong&gt;：任务主动让出控制权（在 await 点），执行流程可预测&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;低开销&lt;&#x2F;strong&gt;：任务是轻量级的状态机（通常几 KB），切换成本低&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;&#x2F;strong&gt;：I&#x2F;O 密集型任务，大量等待操作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;wei-shen-me-xuan-ze-yi-bu&quot;&gt;为什么选择异步？&lt;&#x2F;h3&gt;
&lt;p&gt;考虑一个实际场景：一个 Web 服务器需要同时处理 10,000 个客户端连接。&lt;&#x2F;p&gt;
&lt;p&gt;早期的服务器架构会为每个连接创建一个进程或线程，但在面对上万并发连接时会遇到严重的性能瓶颈，这被称为 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;C10k_problem&quot;&gt;C10K 问题&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;多线程方案的问题&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;10,000 个线程 = 至少 10GB 内存（每个线程栈空间约 1-2MB）&lt;&#x2F;li&gt;
&lt;li&gt;操作系统在这么多线程间切换会产生巨大开销&lt;&#x2F;li&gt;
&lt;li&gt;大部分线程其实在休眠等待（等待客户端发送数据、等待数据库响应等），造成资源浪费&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;异步方案的优势&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;只需要 4-8 个工作线程（对应 CPU 核心数）&lt;&#x2F;li&gt;
&lt;li&gt;10,000 个异步任务可能只占几十 MB 内存&lt;&#x2F;li&gt;
&lt;li&gt;任务在 I&#x2F;O 等待时主动让出 CPU，几乎没有资源浪费&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;异步 I&#x2F;O 模型（配合 epoll、kqueue 等系统调用）是解决 C10K 问题的关键技术之一。现代的高性能服务器（如 Nginx、Node.js）都采用了这种模型。这就是为什么 Tokio、async-std 这样的异步运行时能让 Rust 在高并发场景下表现出色。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;liang-zhe-de-jie-he-zui-jia-shi-jian&quot;&gt;两者的结合：最佳实践&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;异步和多线程不是对立的。&lt;&#x2F;strong&gt; 现代异步运行时（如 Tokio）通常会结合两者，用多个工作线程来利用多核 CPU，并在每个线程上运行大量异步任务。这样既能享受多核并行的性能，又能用异步来高效处理大量 I&#x2F;O 操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-de-yi-bu-mo-xing&quot;&gt;Rust 的异步模型&lt;&#x2F;h2&gt;
&lt;p&gt;Rust 的异步是基于 &lt;strong&gt;Future&lt;&#x2F;strong&gt; 和 &lt;strong&gt;polling&lt;&#x2F;strong&gt; 模型的。理解这几个核心概念是实现异步运行时的基础。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;future-wei-lai-de-ji-suan&quot;&gt;Future：未来的计算&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;Future&lt;&#x2F;code&gt; 是 Rust 异步编程的核心 trait：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Future {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Output;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: Pin&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cx&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Context&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Poll&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Output&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Future&lt;&#x2F;code&gt; 代表一个&quot;未来会产生结果&quot;的计算。它不会自动执行，必须有人去驱动它。&lt;&#x2F;p&gt;
&lt;p&gt;当我们写 &lt;code&gt;async fn&lt;&#x2F;code&gt; 或 &lt;code&gt;async {}&lt;&#x2F;code&gt; 块时，编译器会生成一个实现了 &lt;code&gt;Future&lt;&#x2F;code&gt; trait 的状态机。例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fetch_data&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... async operations
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这会被编译器转换成类似这样的结构：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;FetchDataFuture {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span&gt;: State &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* private, implementation-defined *&#x2F;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ... Other fields
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Future &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;FetchDataFuture {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;Output = String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: Pin&amp;lt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cx&lt;&#x2F;span&gt;&lt;span&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;Context&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; Poll&amp;lt;String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; State machine logic
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TODO&lt;&#x2F;strong&gt;：关于为什么 &lt;code&gt;poll&lt;&#x2F;code&gt; 的第一个参数是 &lt;code&gt;Pin&amp;lt;&amp;amp;mut Self&amp;gt;&lt;&#x2F;code&gt; 而不是 &lt;code&gt;&amp;amp;mut self&lt;&#x2F;code&gt;，涉及到 Rust 的 &lt;code&gt;Pin&lt;&#x2F;code&gt; 机制和自引用结构的问题。这个话题比较复杂，计划在后续单独写一篇文章详细说明。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;poll-lun-xun-jie-guo&quot;&gt;Poll：轮询结果&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Poll&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Ready(T),
&lt;&#x2F;span&gt;&lt;span&gt;    Pending,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Poll&lt;&#x2F;code&gt; 是一个简单的枚举，表示 Future 的状态：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;：Future 还没完成，现在无法产生结果&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Poll::Ready(value)&lt;&#x2F;code&gt;：Future 已完成，这是最终结果&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这是一个基于&quot;拉取&quot;（pull）的模型：执行器主动来问 Future&quot;完成了吗？&quot;，而不是 Future 主动推送结果。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;executor-zhi-xing-qi&quot;&gt;Executor：执行器&lt;&#x2F;h3&gt;
&lt;p&gt;执行器（Executor）负责驱动 Future 的执行。它的核心职责是：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;持有一个或多个 Future&lt;&#x2F;li&gt;
&lt;li&gt;反复调用它们的 &lt;code&gt;poll&lt;&#x2F;code&gt; 方法&lt;&#x2F;li&gt;
&lt;li&gt;当所有 Future 都完成时，执行器的工作也就结束了&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;一个最简单的执行器可能长这样：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;simple_executor&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: Future&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;future&lt;&#x2F;span&gt;&lt;span&gt;: F) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;F::&lt;&#x2F;span&gt;&lt;span&gt;Output {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; future.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;poll&lt;&#x2F;span&gt;&lt;span&gt;(...) {
&lt;&#x2F;span&gt;&lt;span&gt;            Poll::Ready(result) =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result,
&lt;&#x2F;span&gt;&lt;span&gt;            Poll::Pending =&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 等待一会儿再试
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当然，真实的执行器要复杂得多：需要处理多个任务、任务调度、优先级等等。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;waker-huan-xing-ji-zhi&quot;&gt;Waker：唤醒机制&lt;&#x2F;h3&gt;
&lt;p&gt;如果执行器只是盲目地反复调用 &lt;code&gt;poll&lt;&#x2F;code&gt;，那效率会很低——大部分时候 Future 都返回 &lt;code&gt;Pending&lt;&#x2F;code&gt;，这和忙等待（busy waiting）没什么区别。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt; 机制解决了这个问题。它让 Future 能够告诉执行器：&quot;当我准备好继续执行时，我会通知你&quot;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Waker&lt;&#x2F;code&gt; 的工作流程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;执行器在调用 &lt;code&gt;poll&lt;&#x2F;code&gt; 时，通过 &lt;code&gt;Context&lt;&#x2F;code&gt; 传递一个 &lt;code&gt;Waker&lt;&#x2F;code&gt; 给 Future&lt;&#x2F;li&gt;
&lt;li&gt;如果 Future 返回 &lt;code&gt;Pending&lt;&#x2F;code&gt;，它会把这个 &lt;code&gt;Waker&lt;&#x2F;code&gt; 保存起来&lt;&#x2F;li&gt;
&lt;li&gt;当 Future 准备好继续执行时（比如 I&#x2F;O 完成了），它调用 &lt;code&gt;waker.wake()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;执行器收到唤醒通知，知道该再次 &lt;code&gt;poll&lt;&#x2F;code&gt; 这个 Future 了&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这样，执行器就不需要盲目轮询，而是可以休眠等待，直到有任务需要处理。这大大提高了效率。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zheng-ti-liu-cheng&quot;&gt;整体流程&lt;&#x2F;h3&gt;
&lt;p&gt;把这些概念串起来：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;用户编写 &lt;code&gt;async&lt;&#x2F;code&gt; 代码，编译器生成 &lt;code&gt;Future&lt;&#x2F;code&gt; 状态机&lt;&#x2F;li&gt;
&lt;li&gt;用户把 Future 交给 &lt;code&gt;Executor&lt;&#x2F;code&gt; 执行&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;&#x2F;code&gt; 调用 &lt;code&gt;Future::poll()&lt;&#x2F;code&gt;，传入包含 &lt;code&gt;Waker&lt;&#x2F;code&gt; 的 &lt;code&gt;Context&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;如果 &lt;code&gt;Future&lt;&#x2F;code&gt; 返回 &lt;code&gt;Ready&lt;&#x2F;code&gt;，任务完成&lt;&#x2F;li&gt;
&lt;li&gt;如果 &lt;code&gt;Future&lt;&#x2F;code&gt; 返回 &lt;code&gt;Pending&lt;&#x2F;code&gt;，它会在适当的时机调用 &lt;code&gt;Waker::wake()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Executor&lt;&#x2F;code&gt; 收到唤醒通知，再次调用 &lt;code&gt;poll()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;重复步骤 3-6，直到任务完成&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这就是 Rust 异步运行时的核心机制！接下来，我们将通过实现来深入理解这些概念。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hou-xu-ji-hua&quot;&gt;后续计划&lt;&#x2F;h2&gt;
&lt;p&gt;从零开始实现一个教学用的异步运行时，计划逐步实现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;最简单的执行器（忙等待循环）&lt;&#x2F;li&gt;
&lt;li&gt;Waker 机制（高效的任务唤醒）&lt;&#x2F;li&gt;
&lt;li&gt;多任务调度&lt;&#x2F;li&gt;
&lt;li&gt;Timer、Channel、Mutex 等异步原语&lt;&#x2F;li&gt;
&lt;li&gt;多线程执行器&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;第一章将从最简单的执行器开始。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;注&lt;&#x2F;strong&gt;：在实际编写代码的过程中，这些抽象概念会变得更加具体。许多细节在动手实践后会自然理解。&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
