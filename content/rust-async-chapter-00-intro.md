+++
title = "手写Rust异步执行器 第0章：入门"
date = 2025-10-21
description = "从零开始理解 Rust 异步编程：什么是异步、为什么需要异步、异步与多线程的区别，以及 Future、Poll、Executor、Waker 等核心概念。"
weight = 0

[taxonomies]
tags = ["Rust", "async", "异步编程", "并发"]
categories = ["教程/笔记"]

[extra]
series = "理解Rust异步"
toc = true
+++

## 前言

虽然我在近几年写的代码几乎都是同步的，但是最近在学习Rust的过程中，得益于Rust的并发模型很好地规避了初学者在使用时容易踩的坑，因此我也对并发编程有了一定的了解。Rust的并发编程除了多进程和多线程外，还有一套异步编程模型。我尝试过使用 Tokio 这样的异步运行时，但对它们的内部机制始终是一知半解。为了真正理解 Rust 异步编程的底层原理，我决定从零开始实现一个学习性质的异步运行时。它的目标不是打造一个生产级的运行时，而是通过动手实践来深入理解 Future、Waker、Executor 这些概念是如何协同工作的。

本系列笔记记录了我在这个过程中的学习和思考。

在开始动手实现之前，先梳理一下异步编程的基本概念：它是什么、为什么需要它、以及它和多线程的区别。

## 什么是异步编程？

简单来说，异步编程就是一种**让程序在等待某些操作完成的时候，不傻站着干等，而是去做点别的事情**的编程方式。

举个生活中的例子，煮饭的场景：
- **同步方式**：把米放进电饭煲，然后站在那里盯着它煮熟（30分钟），什么都不干。煮好了，再去烧菜（15分钟），烧好了再去煮汤（10分钟）。总共需要 55 分钟。
- **异步方式**：把米放进电饭煲，设好定时器，然后去烧菜。烧菜的同时电饭煲在工作。烧完菜再去煮汤。饭、菜、汤可能在 30-35 分钟内全部完成。

异步编程的核心思想就是：**不要浪费等待的时间**。

在计算机程序中，有大量的操作需要"等待"：
- 从网络读取数据（等待网卡）
- 从磁盘读取文件（等待硬盘）
- 等待用户输入（等待用户）
- 等待数据库查询结果（等待数据库服务器）

这些操作的共同特点是：**CPU 实际上是空闲的，它只是在等外部设备或系统完成工作**。如果能在等待的时候去处理其他任务，程序的效率就会大大提高。

## 异步并发与多线程：为什么选择异步？

在并发编程中，有两种主要的实现方式：多线程和异步。它们经常被混淆，但有着本质的区别。

### 多线程（Parallel/Concurrent）

在多核系统上：
```
线程 1: [==任务A==]     [==任务C==]
线程 2:     [==任务B==]     [==任务D==]
        |----时间线---->
```

在单核系统上：
```
线程 1: [==任务A==][被抢占]  [==任务A继续==][被抢占]
线程 2:          [==任务B==]            [==任务B继续==]
        |----时间线---->
```

**特点：**
- **(可能)真正的并行**：在多核 CPU 上，多个线程可以同时执行；在单核上则是操作系统快速切换造成的"并发"假象
- **抢占式调度**：操作系统决定什么时候切换线程，程序无法控制
- **高开销**：每个线程有独立的栈（通常 1-2MB），上下文切换代价高
- **适用场景**：CPU 密集型任务，需要利用多核心进行计算

### 异步并发（Concurrent）

```
线程 1: [任务A-等待][任务B-等待][任务C-等待][任务A-继续][任务B-继续]
        |----时间线---->
```

**特点：**
- **单线程也能并发**：通过任务切换实现，无需多核支持
- **协作式调度**：任务主动让出控制权（在 await 点），执行流程可预测
- **低开销**：任务是轻量级的状态机（通常几 KB），切换成本低
- **适用场景**：I/O 密集型任务，大量等待操作

### 为什么选择异步？

考虑一个实际场景：一个 Web 服务器需要同时处理 10,000 个客户端连接。

早期的服务器架构会为每个连接创建一个进程或线程，但在面对上万并发连接时会遇到严重的性能瓶颈，这被称为 [C10K 问题](https://en.wikipedia.org/wiki/C10k_problem)。

**多线程方案的问题**：
- 10,000 个线程 = 至少 10GB 内存（每个线程栈空间约 1-2MB）
- 操作系统在这么多线程间切换会产生巨大开销
- 大部分线程其实在休眠等待（等待客户端发送数据、等待数据库响应等），造成资源浪费

**异步方案的优势**：
- 只需要 4-8 个工作线程（对应 CPU 核心数）
- 10,000 个异步任务可能只占几十 MB 内存
- 任务在 I/O 等待时主动让出 CPU，几乎没有资源浪费

异步 I/O 模型（配合 epoll、kqueue 等系统调用）是解决 C10K 问题的关键技术之一。现代的高性能服务器（如 Nginx、Node.js）都采用了这种模型。这就是为什么 Tokio、async-std 这样的异步运行时能让 Rust 在高并发场景下表现出色。

### 两者的结合：最佳实践

**异步和多线程不是对立的。** 现代异步运行时（如 Tokio）通常会结合两者，用多个工作线程来利用多核 CPU，并在每个线程上运行大量异步任务。这样既能享受多核并行的性能，又能用异步来高效处理大量 I/O 操作。

## Rust 的异步模型

Rust 的异步是基于 **Future** 和 **polling** 模型的。理解这几个核心概念是实现异步运行时的基础。

### Future：未来的计算

`Future` 是 Rust 异步编程的核心 trait：

```rust
pub trait Future {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

`Future` 代表一个"未来会产生结果"的计算。它不会自动执行，必须有人去驱动它。

当我们写 `async fn` 或 `async {}` 块时，编译器会生成一个实现了 `Future` trait 的状态机。例如：

```rust
async fn fetch_data() -> String {
    // ... async operations
}
```

这会被编译器转换成类似这样的结构：

```rust
struct FetchDataFuture {
    state: State /* private, implementation-defined */,
    // ... Other fields
}

impl Future for FetchDataFuture {
    type Output = String;
    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<String> {
        // State machine logic
    }
}
```

> **TODO**：关于为什么 `poll` 的第一个参数是 `Pin<&mut Self>` 而不是 `&mut self`，涉及到 Rust 的 `Pin` 机制和自引用结构的问题。这个话题比较复杂，计划在后续单独写一篇文章详细说明。



### Poll：轮询结果

```rust
pub enum Poll<T> {
    Ready(T),
    Pending,
}
```

`Poll` 是一个简单的枚举，表示 Future 的状态：
- `Poll::Pending`：Future 还没完成，现在无法产生结果
- `Poll::Ready(value)`：Future 已完成，这是最终结果

这是一个基于"拉取"（pull）的模型：执行器主动来问 Future"完成了吗？"，而不是 Future 主动推送结果。

### Executor：执行器

执行器（Executor）负责驱动 Future 的执行。它的核心职责是：
1. 持有一个或多个 Future
2. 反复调用它们的 `poll` 方法
3. 当所有 Future 都完成时，执行器的工作也就结束了

一个最简单的执行器可能长这样：

```rust
fn simple_executor<F: Future>(mut future: F) -> F::Output {
    loop {
        match future.poll(...) {
            Poll::Ready(result) => return result,
            Poll::Pending => {
                // 等待一会儿再试
            }
        }
    }
}
```

当然，真实的执行器要复杂得多：需要处理多个任务、任务调度、优先级等等。

### Waker：唤醒机制

如果执行器只是盲目地反复调用 `poll`，那效率会很低——大部分时候 Future 都返回 `Pending`，这和忙等待（busy waiting）没什么区别。

`Waker` 机制解决了这个问题。它让 Future 能够告诉执行器："当我准备好继续执行时，我会通知你"。

`Waker` 的工作流程：
1. 执行器在调用 `poll` 时，通过 `Context` 传递一个 `Waker` 给 Future
2. 如果 Future 返回 `Pending`，它会把这个 `Waker` 保存起来
3. 当 Future 准备好继续执行时（比如 I/O 完成了），它调用 `waker.wake()`
4. 执行器收到唤醒通知，知道该再次 `poll` 这个 Future 了

这样，执行器就不需要盲目轮询，而是可以休眠等待，直到有任务需要处理。这大大提高了效率。

### 整体流程

把这些概念串起来：

1. 用户编写 `async` 代码，编译器生成 `Future` 状态机
2. 用户把 Future 交给 `Executor` 执行
3. `Executor` 调用 `Future::poll()`，传入包含 `Waker` 的 `Context`
4. 如果 `Future` 返回 `Ready`，任务完成
5. 如果 `Future` 返回 `Pending`，它会在适当的时机调用 `Waker::wake()`
6. `Executor` 收到唤醒通知，再次调用 `poll()`
7. 重复步骤 3-6，直到任务完成

这就是 Rust 异步运行时的核心机制！接下来，我们将通过实现来深入理解这些概念。

## 后续计划

从零开始实现一个教学用的异步运行时，计划逐步实现：
- 最简单的执行器（忙等待循环）
- Waker 机制（高效的任务唤醒）
- 多任务调度
- Timer、Channel、Mutex 等异步原语
- 多线程执行器

第一章将从最简单的执行器开始。

---

**注**：在实际编写代码的过程中，这些抽象概念会变得更加具体。许多细节在动手实践后会自然理解。
